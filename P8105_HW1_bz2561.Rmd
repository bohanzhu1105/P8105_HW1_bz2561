---
title: "P8105_HW1_bz2561"
author: "Bohan Zhu"
date: "2025-09-11"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,tidy = TRUE)
```

```{r}
library(ggplot2)
library(tidyverse)
```

## Problem 1
```{r}
library(moderndive)
data("early_january_weather")
```


The dataset shows hourly meteorological data for LGA, JFK, and EWR for the month of January 2013. \
There are `r ncol(early_january_weather)` variables in this dataset, which are `r colnames(early_january_weather)`. \
`origin` represents the weather station. `year`, `month`, `day`, `hour` represents the time of recording. `temp` and `dewp` represents temperature and dewpoint in F. `humid` means relative humidity. `wind_dr`, `wind_speed`, and `wind_gust` shows wind direction (in degrees), speed, and gust speed (in mph). `precip` indicates precipitation, in inches. `presure` calculates sea level pressure in millibars. `visib` shows visibility in miles, and lastely `time_hour` represents the date and hour of the recording as a POSIXct date. \
There are `r nrow(early_january_weather)` data points in the data. \
Besides, the average temperature is `r mean(early_january_weather$temp)` F.

```{r}
ggplot(data = early_january_weather, 
       aes(x = time_hour, y = temp, 
           color = humid)) + 
  geom_point()
```
From the scatter plot, we observe a clear upward trend in temperature over the first two weeks of January, with noticeable daily fluctuations. Despite these short-term variations, the overall pattern indicates steady warming. The humidity color scale does not reveal a strict pattern, as both high and low humidity values appear in the early and later periods. However, lower humidity tends to cluster around lower temperatures, while higher humidity is more frequently associated with higher temperatures.

```{r}
ggsave("scatter_plot_weather.pdf",height = 4,width = 6)
```

## Problem 2
```{r}
set.seed(123)
df1 =
  tibble(
    vec_numeric = rnorm(10),
    vec_logical = (ifelse(vec_numeric > 0, TRUE, FALSE)),
    vec_character = c("Math","Finance","Music","Art","Statistics","Physics",
                      "Marketing","Biology","Accounting","Literature"),
    vec_factor = factor(c("STEM","Business","Humanities","Humanities","STEM","STEM",
                   "Business","STEM","Business","Humanities"))
  )

df1
```
We can see that we can take the mean for numerical variable and logical variable. We can not take the mean for character variable or factor variable. 
```{r}
mean(pull(df1, vec_numeric))
mean(pull(df1, vec_logical))
mean(pull(df1, vec_character))
mean(pull(df1, vec_factor))
```
When we apply as.numeric, we can see that logical vector becomes 0,1 now. 0 represents FALSE and 1 represents TRUE. Hence, is possible to transfer a logical variable to a numerical variable. This is the reason why we may take the mean of a logcial variable. \
For character variable, transforming the variable to numeircal variable results NAs. That is reasonable because character can be anything. \
Finally, for factor vairable, we can see that data now becomes 1 or 2 or 3 because we assign three levels to the data. Here 1 means Business, 2 means Humanities, and 3 means STEM. However, taking the mean for factor variable doesn't have any practical meaning.
```{r, eval=FALSE}
logic_trans = as.numeric((pull(df1, vec_logical)))
character_trans = as.numeric((pull(df1, vec_character)))
factor_trans = as.numeric((pull(df1, vec_factor)))
```

